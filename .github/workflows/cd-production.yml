name: CD - Production

on:
  push:
    tags:
      - 'v*'
  workflow_run:
    workflows:
      - CI - Full
    types:
      - completed
    branches:
      - main

env:
  REGISTRY: ghcr.io

jobs:
  validate:
    runs-on: ubuntu-latest
    outputs:
      tag: ${{ steps.tag.outputs.tag }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Extract tag name
        id: tag
        run: echo "tag=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT
      
      - name: Validate tag format
        run: |
          tag="${{ steps.tag.outputs.tag }}"
          if [[ ! "$tag" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "Invalid tag format: $tag. Must match semantic versioning: vX.Y.Z"
            exit 1
          fi

  build-and-push:
    needs: validate
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Build and push frontend image
        uses: ./.github/actions/docker-build-push
        with:
          context: .
          file: Dockerfile.frontend
          tags: ${{ env.REGISTRY }}/${{ github.repository }}/frontend:${{ needs.validate.outputs.tag }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
      
      - name: Build and push backend image
        uses: ./.github/actions/docker-build-push
        with:
          context: .
          file: Dockerfile.backend
          tags: ${{ env.REGISTRY }}/${{ github.repository }}/backend:${{ needs.validate.outputs.tag }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
      
      - name: Build and push latest images
        uses: ./.github/actions/docker-build-push
        with:
          context: .
          file: Dockerfile.frontend
          tags: ${{ env.REGISTRY }}/${{ github.repository }}/frontend:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
          push: true
      
      - name: Build and push backend latest image
        uses: ./.github/actions/docker-build-push
        with:
          context: .
          file: Dockerfile.backend
          tags: ${{ env.REGISTRY }}/${{ github.repository }}/backend:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

  security-scan:
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:
      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.REGISTRY }}/${{ github.repository }}/backend:${{ needs.validate.outputs.tag }}
          format: 'sarif'
          output: 'trivy-results.sarif'
      
      - name: Upload Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: 'trivy-results.sarif'

  deploy-production:
    needs: [validate, build-and-push, security-scan]
    runs-on: ubuntu-latest
    environment: production
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'
      
      - name: Configure kubectl
        run: |
          echo "${{ secrets.KUBE_CONFIG_PRODUCTION }}" | base64 -d > kubeconfig
          export KUBECONFIG=$PWD/kubeconfig
      
      - name: Create backup before deployment
        run: |
          export KUBECONFIG=$PWD/kubeconfig
          # Create database backup
          kubectl exec -n aquaculture-prod deployment/backend -- \
            python -m alembic backup "${{ needs.validate.outputs.tag }}"
      
      - name: Deploy to production
        run: |
          export KUBECONFIG=$PWD/kubeconfig
          # Update image tags in deployment manifests
          sed -i "s|frontend:latest|${{ env.REGISTRY }}/${{ github.repository }}/frontend:${{ needs.validate.outputs.tag }}|g" deploy/production/frontend-deployment.yaml
          sed -i "s|backend:latest|${{ env.REGISTRY }}/${{ github.repository }}/backend:${{ needs.validate.outputs.tag }}|g" deploy/production/backend-deployment.yaml
          
          # Apply Kubernetes manifests one at a time with health checks
          kubectl apply -f deploy/production/configmap.yaml
          kubectl apply -f deploy/production/secret.yaml
          
          # Deploy backend first (API)
          kubectl apply -f deploy/production/backend-deployment.yaml
          kubectl rollout status deployment/backend -n aquaculture-prod --timeout=10m
          
          # Deploy frontend after backend is healthy
          kubectl apply -f deploy/production/frontend-deployment.yaml
          kubectl rollout status deployment/frontend -n aquaculture-prod --timeout=5m
          
          # Update ingress
          kubectl apply -f deploy/production/ingress.yaml
      
      - name: Run database migrations
        run: |
          export KUBECONFIG=$PWD/kubeconfig
          kubectl exec -n aquaculture-prod deployment/backend -- \
            python -m alembic upgrade head
  
  production-tests:
    needs: deploy-production
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Wait for production deployment
        run: |
          # Wait for ingress to be ready
          timeout 300 bash -c 'until curl -f -s https://app.aquaculture-platform.com/health > /dev/null; do sleep 10; done'
      
      - name: Run production smoke tests
        run: |
          npm ci
          PRODUCTION_URL=https://app.aquaculture-platform.com npm run test:smoke
      
      - name: Run critical path tests
        run: |
          PRODUCTION_URL=https://app.aquaculture-platform.com npm run test:critical-path

  health-verification:
    needs: [deploy-production, production-tests]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
      - name: Run deployment health check
        uses: ./.github/actions/deployment-health-check
        with:
          environment: production
          url: https://app.aquaculture-platform.com
          timeout: 600
      
      - name: Create release for this tag
        if: success()
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ needs.validate.outputs.tag }}
          release_name: Release ${{ needs.validate.outputs.tag }}
          body: |
            Automated deployment of version ${{ needs.validate.outputs.tag }} to production
            
            ## Changes
            - [Add changelog here]
            
            ## Deployment Details
            - Environment: Production
            - Image Tag: ${{ needs.validate.outputs.tag }}
          draft: false
          prerelease: false
      
      - name: Notify Slack on success
        if: success()
        uses: 8398a7/action-slack@v3
        with:
          status: success
          channel: '#ci-cd'
          text: 'Production deployment successful! Version ${{ needs.validate.outputs.tag }} is now live at https://app.aquaculture-platform.com'
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
      
      - name: Notify Slack on failure
        if: failure()
        uses: 8398a7/action-slack@v3
        with:
          status: failure
          channel: '#ci-cd'
          text: 'Production deployment failed for version ${{ needs.validate.outputs.tag }}'
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
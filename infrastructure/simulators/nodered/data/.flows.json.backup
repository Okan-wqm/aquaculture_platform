[
    {
        "id": "flow1",
        "type": "tab",
        "label": "Sensor Simulator",
        "disabled": false,
        "info": "Aquaculture sensor data simulator"
    },
    {
        "id": "inject1",
        "type": "inject",
        "z": "flow1",
        "name": "Every 5 seconds",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "5",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 150,
        "y": 100,
        "wires": [
            [
                "func1"
            ]
        ]
    },
    {
        "id": "func1",
        "type": "function",
        "z": "flow1",
        "name": "Generate Water Quality Data",
        "func": "const vary = (val, pct) => +(val + (Math.random() - 0.5) * 2 * val * pct).toFixed(2); msg.payload = { deviceId: 'WQM-001', timestamp: new Date().toISOString(), ph: vary(7.2, 0.05), temperature: vary(28.5, 0.03), dissolved_oxygen: vary(6.8, 0.05), salinity: vary(32.1, 0.02), turbidity: vary(4.2, 0.1), ammonia: vary(0.02, 0.15) }; return msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 100,
        "wires": [
            [
                "mqtt1",
                "debug1"
            ]
        ]
    },
    {
        "id": "mqtt1",
        "type": "mqtt out",
        "z": "flow1",
        "name": "Publish to MQTT",
        "topic": "sensors/farm-01/pool-01/water-quality",
        "qos": "0",
        "retain": "false",
        "broker": "broker1",
        "x": 630,
        "y": 100,
        "wires": []
    },
    {
        "id": "debug1",
        "type": "debug",
        "z": "flow1",
        "name": "Show Data",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": true,
        "complete": "payload",
        "targetType": "msg",
        "x": 610,
        "y": 160,
        "wires": []
    },
    {
        "id": "inject2",
        "type": "inject",
        "z": "flow1",
        "name": "Every 10 seconds",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "10",
        "crontab": "",
        "once": true,
        "onceDelay": "2",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 160,
        "y": 240,
        "wires": [
            [
                "func2"
            ]
        ]
    },
    {
        "id": "func2",
        "type": "function",
        "z": "flow1",
        "name": "Generate Temp Array",
        "func": "const vary = (val, pct) => +(val + (Math.random() - 0.5) * 2 * val * pct).toFixed(2); msg.payload = { deviceId: 'TEMP-ARRAY-001', timestamp: new Date().toISOString(), sensors: { surface: vary(29.1, 0.02), mid: vary(28.5, 0.02), bottom: vary(27.8, 0.02) } }; return msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 240,
        "wires": [
            [
                "mqtt2",
                "debug2"
            ]
        ]
    },
    {
        "id": "mqtt2",
        "type": "mqtt out",
        "z": "flow1",
        "name": "Publish Temp Array",
        "topic": "sensors/farm-01/pool-02/temperature-array",
        "qos": "0",
        "retain": "false",
        "broker": "broker1",
        "x": 630,
        "y": 240,
        "wires": []
    },
    {
        "id": "debug2",
        "type": "debug",
        "z": "flow1",
        "name": "Show Temps",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": true,
        "complete": "payload",
        "targetType": "msg",
        "x": 610,
        "y": 300,
        "wires": []
    },
    {
        "id": "inject3",
        "type": "inject",
        "z": "flow1",
        "name": "Every 3 seconds",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "3",
        "crontab": "",
        "once": true,
        "onceDelay": "3",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 150,
        "y": 380,
        "wires": [
            [
                "func3"
            ]
        ]
    },
    {
        "id": "func3",
        "type": "function",
        "z": "flow1",
        "name": "Generate Flow Data",
        "func": "const vary = (val, pct) => +(val + (Math.random() - 0.5) * 2 * val * pct).toFixed(2); msg.payload = { deviceId: 'FLOW-001', timestamp: new Date().toISOString(), flow_rate: vary(125.5, 0.05), pressure: vary(2.4, 0.03), valve_position: Math.floor(70 + Math.random() * 10) }; return msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 370,
        "y": 380,
        "wires": [
            [
                "mqtt3",
                "debug3"
            ]
        ]
    },
    {
        "id": "mqtt3",
        "type": "mqtt out",
        "z": "flow1",
        "name": "Publish Flow",
        "topic": "sensors/farm-01/system/flow",
        "qos": "0",
        "retain": "false",
        "broker": "broker1",
        "x": 610,
        "y": 380,
        "wires": []
    },
    {
        "id": "debug3",
        "type": "debug",
        "z": "flow1",
        "name": "Show Flow",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": true,
        "complete": "payload",
        "targetType": "msg",
        "x": 610,
        "y": 440,
        "wires": []
    },
    {
        "id": "broker1",
        "type": "mqtt-broker",
        "name": "Mosquitto Local",
        "broker": "mosquitto",
        "port": "1883",
        "clientid": "nodered-simulator",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": "60",
        "cleansession": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthPayload": "",
        "closeTopic": "",
        "closePayload": "",
        "willTopic": "",
        "willQos": "0",
        "willPayload": ""
    },
    {
        "id": "equipment-flow",
        "type": "tab",
        "label": "Equipment Simulator",
        "disabled": false,
        "info": "MQTT-based equipment simulator with realistic behavior (motors, valves, lights)"
    },
    {
        "id": "comment-commands",
        "type": "comment",
        "z": "equipment-flow",
        "name": "=== KOMUT ALIMLARI ===",
        "info": "",
        "x": 140,
        "y": 40,
        "wires": []
    },
    {
        "id": "mqtt-in-motor",
        "type": "mqtt in",
        "z": "equipment-flow",
        "name": "Motor Commands",
        "topic": "equipment/command/motor/+",
        "qos": "1",
        "datatype": "json",
        "broker": "broker1",
        "nl": false,
        "rap": false,
        "inputs": 0,
        "x": 130,
        "y": 100,
        "wires": [
            [
                "motor-handler"
            ]
        ]
    },
    {
        "id": "mqtt-in-valve",
        "type": "mqtt in",
        "z": "equipment-flow",
        "name": "Valve Commands",
        "topic": "equipment/command/valve/+",
        "qos": "1",
        "datatype": "json",
        "broker": "broker1",
        "nl": false,
        "rap": false,
        "inputs": 0,
        "x": 130,
        "y": 160,
        "wires": [
            [
                "valve-handler"
            ]
        ]
    },
    {
        "id": "mqtt-in-light",
        "type": "mqtt in",
        "z": "equipment-flow",
        "name": "Light Commands",
        "topic": "equipment/command/light/+",
        "qos": "1",
        "datatype": "json",
        "broker": "broker1",
        "nl": false,
        "rap": false,
        "inputs": 0,
        "x": 130,
        "y": 220,
        "wires": [
            [
                "light-handler"
            ]
        ]
    },
    {
        "id": "motor-handler",
        "type": "function",
        "z": "equipment-flow",
        "name": "Motor Command Handler",
        "func": "// Motor configurations\nconst motorConfigs = {\n    'MOTOR-VFD-001': { name: 'Ana Pompa', maxCurrent: 15, maxRpm: 3000 },\n    'MOTOR-VFD-002': { name: 'Sirkulasyon Pompasi', maxCurrent: 10, maxRpm: 2400 },\n    'MOTOR-VFD-003': { name: 'Transfer Pompasi', maxCurrent: 8, maxRpm: 1800 }\n};\n\n// Get or initialize motors state\nlet motors = flow.get('motors') || {};\nfor (let id in motorConfigs) {\n    if (!motors[id]) {\n        motors[id] = {\n            state: 'STOPPED',\n            speed: 0,\n            targetSpeed: 0,\n            current: 0,\n            rpm: 0,\n            runHours: 0,\n            config: motorConfigs[id]\n        };\n    }\n}\n\n// Extract deviceId from topic\nconst topicParts = msg.topic.split('/');\nconst deviceId = topicParts[topicParts.length - 1];\nconst cmd = msg.payload;\n\nif (!motors[deviceId]) {\n    node.warn('Unknown motor: ' + deviceId);\n    return null;\n}\n\nconst motor = motors[deviceId];\n\n// Process command\nswitch (cmd.action) {\n    case 'START':\n        motor.targetSpeed = cmd.speed || 100;\n        motor.state = 'STARTING';\n        break;\n    case 'STOP':\n        motor.targetSpeed = 0;\n        motor.state = 'STOPPING';\n        break;\n    case 'SET_SPEED':\n        if (motor.state === 'RUNNING' || motor.state === 'STARTING') {\n            motor.targetSpeed = cmd.speed || motor.targetSpeed;\n            if (motor.targetSpeed > motor.speed) {\n                motor.state = 'STARTING';\n            } else if (motor.targetSpeed < motor.speed) {\n                motor.state = 'STOPPING';\n            }\n        }\n        break;\n    case 'GET_STATUS':\n        // Just send current status\n        break;\n    default:\n        node.warn('Unknown action: ' + cmd.action);\n        return null;\n}\n\nflow.set('motors', motors);\n\n// Build status message\nmsg.topic = 'equipment/status/motor/' + deviceId;\nmsg.payload = {\n    deviceId: deviceId,\n    deviceType: 'motor',\n    name: motor.config.name,\n    state: motor.state,\n    speed: motor.speed,\n    targetSpeed: motor.targetSpeed,\n    current: motor.current,\n    rpm: motor.rpm,\n    runHours: motor.runHours,\n    timestamp: new Date().toISOString()\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 100,
        "wires": [
            [
                "mqtt-out-status",
                "debug-motor"
            ]
        ]
    },
    {
        "id": "valve-handler",
        "type": "function",
        "z": "equipment-flow",
        "name": "Valve Command Handler",
        "func": "// Valve configurations\nconst valveConfigs = {\n    'VALVE-001': { name: 'Giris Vanasi', transitionTime: 2000 },\n    'VALVE-002': { name: 'Cikis Vanasi', transitionTime: 2000 },\n    'VALVE-003': { name: 'Bypass Vanasi', transitionTime: 1500 }\n};\n\n// Get or initialize valves state\nlet valves = flow.get('valves') || {};\nfor (let id in valveConfigs) {\n    if (!valves[id]) {\n        valves[id] = {\n            state: 'CLOSED',\n            position: 0,\n            targetPosition: 0,\n            config: valveConfigs[id]\n        };\n    }\n}\n\n// Extract deviceId from topic\nconst topicParts = msg.topic.split('/');\nconst deviceId = topicParts[topicParts.length - 1];\nconst cmd = msg.payload;\n\nif (!valves[deviceId]) {\n    node.warn('Unknown valve: ' + deviceId);\n    return null;\n}\n\nconst valve = valves[deviceId];\n\n// Process command\nswitch (cmd.action) {\n    case 'OPEN':\n        valve.targetPosition = 100;\n        valve.state = 'OPENING';\n        break;\n    case 'CLOSE':\n        valve.targetPosition = 0;\n        valve.state = 'CLOSING';\n        break;\n    case 'TOGGLE':\n        if (valve.state === 'OPEN' || valve.state === 'OPENING') {\n            valve.targetPosition = 0;\n            valve.state = 'CLOSING';\n        } else {\n            valve.targetPosition = 100;\n            valve.state = 'OPENING';\n        }\n        break;\n    case 'GET_STATUS':\n        // Just send current status\n        break;\n    default:\n        node.warn('Unknown action: ' + cmd.action);\n        return null;\n}\n\nflow.set('valves', valves);\n\n// Build status message\nmsg.topic = 'equipment/status/valve/' + deviceId;\nmsg.payload = {\n    deviceId: deviceId,\n    deviceType: 'valve',\n    name: valve.config.name,\n    state: valve.state,\n    position: valve.position,\n    targetPosition: valve.targetPosition,\n    timestamp: new Date().toISOString()\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 160,
        "wires": [
            [
                "mqtt-out-status",
                "debug-valve"
            ]
        ]
    },
    {
        "id": "light-handler",
        "type": "function",
        "z": "equipment-flow",
        "name": "Light Command Handler",
        "func": "// Light configurations\nconst lightConfigs = {\n    'LIGHT-001': { name: 'Havuz Isigi', maxPower: 500 },\n    'LIGHT-002': { name: 'Ortam Isigi', maxPower: 200 }\n};\n\n// Get or initialize lights state\nlet lights = flow.get('lights') || {};\nfor (let id in lightConfigs) {\n    if (!lights[id]) {\n        lights[id] = {\n            state: 'OFF',\n            brightness: 0,\n            targetBrightness: 0,\n            power: 0,\n            config: lightConfigs[id]\n        };\n    }\n}\n\n// Extract deviceId from topic\nconst topicParts = msg.topic.split('/');\nconst deviceId = topicParts[topicParts.length - 1];\nconst cmd = msg.payload;\n\nif (!lights[deviceId]) {\n    node.warn('Unknown light: ' + deviceId);\n    return null;\n}\n\nconst light = lights[deviceId];\n\n// Process command\nswitch (cmd.action) {\n    case 'ON':\n        light.targetBrightness = 100;\n        light.state = 'ON';\n        break;\n    case 'OFF':\n        light.targetBrightness = 0;\n        light.state = 'OFF';\n        break;\n    case 'SET_BRIGHTNESS':\n        light.targetBrightness = Math.max(0, Math.min(100, cmd.brightness || 0));\n        light.state = light.targetBrightness > 0 ? 'ON' : 'OFF';\n        break;\n    case 'GET_STATUS':\n        // Just send current status\n        break;\n    default:\n        node.warn('Unknown action: ' + cmd.action);\n        return null;\n}\n\nflow.set('lights', lights);\n\n// Build status message\nmsg.topic = 'equipment/status/light/' + deviceId;\nmsg.payload = {\n    deviceId: deviceId,\n    deviceType: 'light',\n    name: light.config.name,\n    state: light.state,\n    brightness: light.brightness,\n    targetBrightness: light.targetBrightness,\n    power: light.power,\n    timestamp: new Date().toISOString()\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 220,
        "wires": [
            [
                "mqtt-out-status",
                "debug-light"
            ]
        ]
    },
    {
        "id": "mqtt-out-status",
        "type": "mqtt out",
        "z": "equipment-flow",
        "name": "Publish Status",
        "topic": "",
        "qos": "1",
        "retain": "true",
        "broker": "broker1",
        "x": 620,
        "y": 160,
        "wires": []
    },
    {
        "id": "debug-motor",
        "type": "debug",
        "z": "equipment-flow",
        "name": "Motor Status",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": true,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "payload.state",
        "statusType": "auto",
        "x": 610,
        "y": 100,
        "wires": []
    },
    {
        "id": "debug-valve",
        "type": "debug",
        "z": "equipment-flow",
        "name": "Valve Status",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": true,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "payload.state",
        "statusType": "auto",
        "x": 610,
        "y": 200,
        "wires": []
    },
    {
        "id": "debug-light",
        "type": "debug",
        "z": "equipment-flow",
        "name": "Light Status",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": true,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "payload.state",
        "statusType": "auto",
        "x": 610,
        "y": 260,
        "wires": []
    },
    {
        "id": "comment-simulation",
        "type": "comment",
        "z": "equipment-flow",
        "name": "=== SIMULASYON TICK ===",
        "info": "",
        "x": 150,
        "y": 320,
        "wires": []
    },
    {
        "id": "inject-tick",
        "type": "inject",
        "z": "equipment-flow",
        "name": "Every 500ms (Simulation Tick)",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "0.5",
        "crontab": "",
        "once": true,
        "onceDelay": "2",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 190,
        "y": 380,
        "wires": [
            [
                "simulation-tick"
            ]
        ]
    },
    {
        "id": "simulation-tick",
        "type": "function",
        "z": "equipment-flow",
        "name": "Simulation Tick (Realistic Updates)",
        "func": "const vary = (val, pct) => val + (Math.random() - 0.5) * 2 * val * pct;\nconst TICK_INTERVAL = 0.5; // seconds\nconst messages = [];\n\n// === MOTOR SIMULATION ===\nlet motors = flow.get('motors') || {};\nfor (let deviceId in motors) {\n    const motor = motors[deviceId];\n    const config = motor.config;\n    let changed = false;\n    \n    // Speed ramping (soft start/stop)\n    const speedStep = 5; // % per tick (10% per second)\n    if (motor.speed < motor.targetSpeed) {\n        motor.speed = Math.min(motor.speed + speedStep, motor.targetSpeed);\n        changed = true;\n    } else if (motor.speed > motor.targetSpeed) {\n        motor.speed = Math.max(motor.speed - speedStep * 1.5, motor.targetSpeed); // Faster stop\n        changed = true;\n    }\n    \n    // State transitions\n    if (motor.state === 'STARTING' && motor.speed >= motor.targetSpeed && motor.speed > 0) {\n        motor.state = 'RUNNING';\n        changed = true;\n    } else if (motor.state === 'STOPPING' && motor.speed === 0) {\n        motor.state = 'STOPPED';\n        changed = true;\n    }\n    \n    // Calculate current and RPM based on speed\n    if (motor.speed > 0) {\n        // Current: higher at startup (1.5x), normalizes when running\n        const startupMultiplier = motor.state === 'STARTING' ? 1.5 : 1.0;\n        motor.current = +((config.maxCurrent * (motor.speed / 100) * startupMultiplier) * (1 + (Math.random() - 0.5) * 0.04)).toFixed(2);\n        \n        // RPM with small variation\n        motor.rpm = Math.round(config.maxRpm * (motor.speed / 100) * (1 + (Math.random() - 0.5) * 0.02));\n        \n        // Accumulate run hours\n        motor.runHours = +((motor.runHours || 0) + TICK_INTERVAL / 3600).toFixed(4);\n    } else {\n        motor.current = 0;\n        motor.rpm = 0;\n    }\n    \n    // Send status update if changed or every 2 seconds (4 ticks)\n    const tickCount = flow.get('tickCount') || 0;\n    if (changed || tickCount % 4 === 0) {\n        messages.push({\n            topic: 'equipment/status/motor/' + deviceId,\n            payload: {\n                deviceId: deviceId,\n                deviceType: 'motor',\n                name: config.name,\n                state: motor.state,\n                speed: motor.speed,\n                targetSpeed: motor.targetSpeed,\n                current: motor.current,\n                rpm: motor.rpm,\n                runHours: motor.runHours,\n                timestamp: new Date().toISOString()\n            }\n        });\n    }\n}\nflow.set('motors', motors);\n\n// === VALVE SIMULATION ===\nlet valves = flow.get('valves') || {};\nfor (let deviceId in valves) {\n    const valve = valves[deviceId];\n    const config = valve.config;\n    let changed = false;\n    \n    // Position change (based on transition time)\n    const positionStep = 100 / (config.transitionTime / 1000 / TICK_INTERVAL); // % per tick\n    \n    if (valve.position < valve.targetPosition) {\n        valve.position = Math.min(valve.position + positionStep, valve.targetPosition);\n        changed = true;\n    } else if (valve.position > valve.targetPosition) {\n        valve.position = Math.max(valve.position - positionStep, valve.targetPosition);\n        changed = true;\n    }\n    \n    // State transitions\n    if (valve.state === 'OPENING' && valve.position >= 100) {\n        valve.state = 'OPEN';\n        valve.position = 100;\n        changed = true;\n    } else if (valve.state === 'CLOSING' && valve.position <= 0) {\n        valve.state = 'CLOSED';\n        valve.position = 0;\n        changed = true;\n    }\n    \n    // Send status update if changed or every 2 seconds\n    const tickCount = flow.get('tickCount') || 0;\n    if (changed || tickCount % 4 === 0) {\n        messages.push({\n            topic: 'equipment/status/valve/' + deviceId,\n            payload: {\n                deviceId: deviceId,\n                deviceType: 'valve',\n                name: config.name,\n                state: valve.state,\n                position: Math.round(valve.position),\n                targetPosition: valve.targetPosition,\n                timestamp: new Date().toISOString()\n            }\n        });\n    }\n}\nflow.set('valves', valves);\n\n// === LIGHT SIMULATION ===\nlet lights = flow.get('lights') || {};\nfor (let deviceId in lights) {\n    const light = lights[deviceId];\n    const config = light.config;\n    let changed = false;\n    \n    // Brightness fade (1 second transition)\n    const brightnessStep = 100 / (1000 / 1000 / TICK_INTERVAL); // 100% per second\n    \n    if (light.brightness < light.targetBrightness) {\n        light.brightness = Math.min(light.brightness + brightnessStep, light.targetBrightness);\n        changed = true;\n    } else if (light.brightness > light.targetBrightness) {\n        light.brightness = Math.max(light.brightness - brightnessStep, light.targetBrightness);\n        changed = true;\n    }\n    \n    // Update state based on brightness\n    if (light.brightness > 0 && light.state !== 'ON') {\n        light.state = 'ON';\n        changed = true;\n    } else if (light.brightness === 0 && light.state !== 'OFF') {\n        light.state = 'OFF';\n        changed = true;\n    }\n    \n    // Calculate power consumption\n    light.power = Math.round(config.maxPower * (light.brightness / 100));\n    \n    // Send status update if changed or every 2 seconds\n    const tickCount = flow.get('tickCount') || 0;\n    if (changed || tickCount % 4 === 0) {\n        messages.push({\n            topic: 'equipment/status/light/' + deviceId,\n            payload: {\n                deviceId: deviceId,\n                deviceType: 'light',\n                name: config.name,\n                state: light.state,\n                brightness: Math.round(light.brightness),\n                targetBrightness: light.targetBrightness,\n                power: light.power,\n                timestamp: new Date().toISOString()\n            }\n        });\n    }\n}\nflow.set('lights', lights);\n\n// Increment tick counter\nflow.set('tickCount', (flow.get('tickCount') || 0) + 1);\n\n// Return all messages\nif (messages.length > 0) {\n    return [messages];\n}\nreturn null;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "// Initialize equipment state on deploy\nconst motorConfigs = {\n    'MOTOR-VFD-001': { name: 'Ana Pompa', maxCurrent: 15, maxRpm: 3000 },\n    'MOTOR-VFD-002': { name: 'Sirkulasyon Pompasi', maxCurrent: 10, maxRpm: 2400 },\n    'MOTOR-VFD-003': { name: 'Transfer Pompasi', maxCurrent: 8, maxRpm: 1800 }\n};\n\nconst valveConfigs = {\n    'VALVE-001': { name: 'Giris Vanasi', transitionTime: 2000 },\n    'VALVE-002': { name: 'Cikis Vanasi', transitionTime: 2000 },\n    'VALVE-003': { name: 'Bypass Vanasi', transitionTime: 1500 }\n};\n\nconst lightConfigs = {\n    'LIGHT-001': { name: 'Havuz Isigi', maxPower: 500 },\n    'LIGHT-002': { name: 'Ortam Isigi', maxPower: 200 }\n};\n\n// Initialize motors\nlet motors = {};\nfor (let id in motorConfigs) {\n    motors[id] = {\n        state: 'STOPPED',\n        speed: 0,\n        targetSpeed: 0,\n        current: 0,\n        rpm: 0,\n        runHours: 0,\n        config: motorConfigs[id]\n    };\n}\nflow.set('motors', motors);\n\n// Initialize valves\nlet valves = {};\nfor (let id in valveConfigs) {\n    valves[id] = {\n        state: 'CLOSED',\n        position: 0,\n        targetPosition: 0,\n        config: valveConfigs[id]\n    };\n}\nflow.set('valves', valves);\n\n// Initialize lights\nlet lights = {};\nfor (let id in lightConfigs) {\n    lights[id] = {\n        state: 'OFF',\n        brightness: 0,\n        targetBrightness: 0,\n        power: 0,\n        config: lightConfigs[id]\n    };\n}\nflow.set('lights', lights);\n\nflow.set('tickCount', 0);",
        "finalize": "",
        "libs": [],
        "x": 470,
        "y": 380,
        "wires": [
            [
                "mqtt-out-tick"
            ]
        ]
    },
    {
        "id": "mqtt-out-tick",
        "type": "mqtt out",
        "z": "equipment-flow",
        "name": "Publish Tick Status",
        "topic": "",
        "qos": "0",
        "retain": "false",
        "broker": "broker1",
        "x": 730,
        "y": 380,
        "wires": []
    },
    {
        "id": "comment-broadcast",
        "type": "comment",
        "z": "equipment-flow",
        "name": "=== PERIYODIK BROADCAST ===",
        "info": "",
        "x": 170,
        "y": 460,
        "wires": []
    },
    {
        "id": "inject-broadcast",
        "type": "inject",
        "z": "equipment-flow",
        "name": "Every 5 seconds (All Status)",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "5",
        "crontab": "",
        "once": true,
        "onceDelay": "3",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 180,
        "y": 520,
        "wires": [
            [
                "broadcast-all"
            ]
        ]
    },
    {
        "id": "broadcast-all",
        "type": "function",
        "z": "equipment-flow",
        "name": "Broadcast All Equipment Status",
        "func": "const motors = flow.get('motors') || {};\nconst valves = flow.get('valves') || {};\nconst lights = flow.get('lights') || {};\n\nconst allStatus = {\n    timestamp: new Date().toISOString(),\n    motors: {},\n    valves: {},\n    lights: {}\n};\n\n// Collect motor statuses\nfor (let id in motors) {\n    const m = motors[id];\n    allStatus.motors[id] = {\n        deviceId: id,\n        name: m.config.name,\n        state: m.state,\n        speed: m.speed,\n        targetSpeed: m.targetSpeed,\n        current: m.current,\n        rpm: m.rpm,\n        runHours: m.runHours\n    };\n}\n\n// Collect valve statuses\nfor (let id in valves) {\n    const v = valves[id];\n    allStatus.valves[id] = {\n        deviceId: id,\n        name: v.config.name,\n        state: v.state,\n        position: Math.round(v.position),\n        targetPosition: v.targetPosition\n    };\n}\n\n// Collect light statuses\nfor (let id in lights) {\n    const l = lights[id];\n    allStatus.lights[id] = {\n        deviceId: id,\n        name: l.config.name,\n        state: l.state,\n        brightness: Math.round(l.brightness),\n        targetBrightness: l.targetBrightness,\n        power: l.power\n    };\n}\n\nmsg.topic = 'equipment/status/all';\nmsg.payload = allStatus;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 470,
        "y": 520,
        "wires": [
            [
                "mqtt-out-broadcast",
                "debug-broadcast"
            ]
        ]
    },
    {
        "id": "mqtt-out-broadcast",
        "type": "mqtt out",
        "z": "equipment-flow",
        "name": "Publish All Status",
        "topic": "",
        "qos": "0",
        "retain": "true",
        "broker": "broker1",
        "x": 730,
        "y": 520,
        "wires": []
    },
    {
        "id": "debug-broadcast",
        "type": "debug",
        "z": "equipment-flow",
        "name": "All Equipment Status",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "x": 740,
        "y": 580,
        "wires": []
    },
    {
        "id": "edge-flow",
        "type": "tab",
        "label": "Edge Device Simulator",
        "disabled": false,
        "info": "Industrial IoT Edge Device Simulator - Simulates Revolution Pi and Industrial PC controllers sending heartbeat data to cloud"
    },
    {
        "id": "comment-devices",
        "type": "comment",
        "z": "edge-flow",
        "name": "=== EDGE DEVICE HEARTBEAT SIMULATOR ===",
        "info": "Simulates edge controllers (Revolution Pi, Industrial PC) sending periodic health metrics to cloud via MQTT",
        "x": 200,
        "y": 40,
        "wires": []
    },
    {
        "id": "inject-birth",
        "type": "inject",
        "z": "edge-flow",
        "name": "On Deploy: Send Birth",
        "props": [{"p": "payload"}],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "2",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 160,
        "y": 120,
        "wires": [["birth-handler"]]
    },
    {
        "id": "birth-handler",
        "type": "function",
        "z": "edge-flow",
        "name": "Send Birth Certificates",
        "func": "// Edge device configurations\nconst devices = [\n    {\n        code: 'RPI-SIM-001',\n        name: 'Revolution Pi Simulator 1',\n        model: 'REVOLUTION_PI_CONNECT_4',\n        firmware: '2.5.1-sim',\n        ip: '192.168.1.101'\n    },\n    {\n        code: 'IPC-SIM-001',\n        name: 'Industrial PC Simulator',\n        model: 'INDUSTRIAL_PC',\n        firmware: '3.0.0-sim',\n        ip: '192.168.1.102'\n    }\n];\n\n// Initialize device state\nlet deviceStates = {};\ndevices.forEach(dev => {\n    deviceStates[dev.code] = {\n        config: dev,\n        uptimeSeconds: 0,\n        cpuUsage: 20 + Math.random() * 20,\n        memoryUsage: 40 + Math.random() * 20,\n        storageUsage: 25 + Math.random() * 15,\n        temperatureCelsius: 38 + Math.random() * 10\n    };\n});\nflow.set('deviceStates', deviceStates);\n\n// Send birth certificate for each device\nconst messages = devices.map(dev => ({\n    topic: `edge/${dev.code}/birth`,\n    payload: {\n        deviceCode: dev.code,\n        timestamp: new Date().toISOString(),\n        firmwareVersion: dev.firmware,\n        ipAddress: dev.ip,\n        properties: {\n            hardwareMake: dev.model.includes('REVOLUTION') ? 'KUNBUS' : 'Custom',\n            hardwareModel: dev.model,\n            firmwareVersion: dev.firmware\n        }\n    }\n}));\n\nnode.status({ fill: 'green', shape: 'dot', text: `${devices.length} devices born` });\nreturn [messages];",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 420,
        "y": 120,
        "wires": [["mqtt-out-edge"]]
    },
    {
        "id": "inject-heartbeat",
        "type": "inject",
        "z": "edge-flow",
        "name": "Every 10 seconds (Heartbeat)",
        "props": [{"p": "payload"}],
        "repeat": "10",
        "crontab": "",
        "once": true,
        "onceDelay": "5",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 180,
        "y": 200,
        "wires": [["heartbeat-generator"]]
    },
    {
        "id": "heartbeat-generator",
        "type": "function",
        "z": "edge-flow",
        "name": "Generate Heartbeat Data",
        "func": "const deviceStates = flow.get('deviceStates') || {};\nconst messages = [];\n\nfor (let code in deviceStates) {\n    const state = deviceStates[code];\n    const config = state.config;\n    \n    // Update uptime\n    state.uptimeSeconds += 10;\n    \n    // Simulate realistic metric variations\n    // CPU: varies between 15-75% with occasional spikes\n    const cpuSpike = Math.random() < 0.1 ? 30 : 0; // 10% chance of spike\n    state.cpuUsage = Math.max(15, Math.min(85, state.cpuUsage + (Math.random() - 0.5) * 10 + cpuSpike));\n    \n    // Memory: slowly increases, occasionally drops (GC)\n    const gcDrop = Math.random() < 0.05 ? -15 : 0; // 5% chance of GC\n    state.memoryUsage = Math.max(35, Math.min(80, state.memoryUsage + Math.random() * 2 - 0.5 + gcDrop));\n    \n    // Storage: very slowly increases\n    state.storageUsage = Math.min(60, state.storageUsage + Math.random() * 0.01);\n    \n    // Temperature: varies with CPU, ambient temperature simulation\n    const cpuHeat = state.cpuUsage * 0.2;\n    state.temperatureCelsius = Math.max(35, Math.min(65, 35 + cpuHeat + (Math.random() - 0.5) * 3));\n    \n    // Create heartbeat message\n    messages.push({\n        topic: `edge/${code}/heartbeat`,\n        payload: {\n            deviceCode: code,\n            timestamp: new Date().toISOString(),\n            isOnline: true,\n            cpuUsage: Math.round(state.cpuUsage),\n            memoryUsage: Math.round(state.memoryUsage),\n            storageUsage: Math.round(state.storageUsage),\n            temperatureCelsius: +state.temperatureCelsius.toFixed(1),\n            uptimeSeconds: state.uptimeSeconds,\n            firmwareVersion: config.firmware,\n            ipAddress: config.ip\n        }\n    });\n}\n\nflow.set('deviceStates', deviceStates);\n\nconst count = Object.keys(deviceStates).length;\nnode.status({ fill: 'blue', shape: 'ring', text: `${count} heartbeats sent` });\n\nreturn [messages];",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 440,
        "y": 200,
        "wires": [["mqtt-out-edge", "debug-heartbeat"]]
    },
    {
        "id": "comment-edge-commands",
        "type": "comment",
        "z": "edge-flow",
        "name": "=== COMMAND HANDLING ===",
        "info": "Handle commands from cloud (ping, reboot, config)",
        "x": 160,
        "y": 300,
        "wires": []
    },
    {
        "id": "mqtt-in-ping",
        "type": "mqtt in",
        "z": "edge-flow",
        "name": "Ping Commands",
        "topic": "edge/+/cmd/ping",
        "qos": "1",
        "datatype": "json",
        "broker": "broker1",
        "nl": false,
        "rap": false,
        "inputs": 0,
        "x": 130,
        "y": 360,
        "wires": [["ping-handler"]]
    },
    {
        "id": "ping-handler",
        "type": "function",
        "z": "edge-flow",
        "name": "Handle Ping",
        "func": "const topicParts = msg.topic.split('/');\nconst deviceCode = topicParts[1];\nconst commandId = msg.payload.commandId || 'unknown';\n\n// Simulate network latency (10-50ms)\nconst latency = Math.floor(10 + Math.random() * 40);\n\nmsg.topic = `edge/${deviceCode}/response`;\nmsg.payload = {\n    commandId: commandId,\n    command: 'ping',\n    success: true,\n    data: {\n        pong: true,\n        latencyMs: latency,\n        timestamp: new Date().toISOString()\n    }\n};\n\nnode.status({ fill: 'green', shape: 'dot', text: `Ping response: ${deviceCode}` });\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 370,
        "y": 360,
        "wires": [["mqtt-out-edge", "debug-response"]]
    },
    {
        "id": "mqtt-in-reboot",
        "type": "mqtt in",
        "z": "edge-flow",
        "name": "Reboot Commands",
        "topic": "edge/+/cmd/reboot",
        "qos": "1",
        "datatype": "json",
        "broker": "broker1",
        "nl": false,
        "rap": false,
        "inputs": 0,
        "x": 140,
        "y": 420,
        "wires": [["reboot-handler"]]
    },
    {
        "id": "reboot-handler",
        "type": "function",
        "z": "edge-flow",
        "name": "Handle Reboot (Simulated)",
        "func": "const topicParts = msg.topic.split('/');\nconst deviceCode = topicParts[1];\nconst reason = msg.payload.reason || 'User request';\n\n// Send death message first\nconst deathMsg = {\n    topic: `edge/${deviceCode}/death`,\n    payload: {\n        deviceCode: deviceCode,\n        timestamp: new Date().toISOString(),\n        reason: `Reboot requested: ${reason}`\n    }\n};\n\n// Reset device state\nlet deviceStates = flow.get('deviceStates') || {};\nif (deviceStates[deviceCode]) {\n    deviceStates[deviceCode].uptimeSeconds = 0;\n    deviceStates[deviceCode].cpuUsage = 25;\n    deviceStates[deviceCode].memoryUsage = 45;\n    flow.set('deviceStates', deviceStates);\n}\n\nnode.status({ fill: 'yellow', shape: 'ring', text: `Rebooting: ${deviceCode}` });\n\n// Return death message now, birth will come from delayed inject\nreturn deathMsg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 410,
        "y": 420,
        "wires": [["mqtt-out-edge", "delay-reboot"]]
    },
    {
        "id": "delay-reboot",
        "type": "delay",
        "z": "edge-flow",
        "name": "Reboot Delay (5s)",
        "pauseType": "delay",
        "timeout": "5",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 630,
        "y": 420,
        "wires": [["reboot-birth"]]
    },
    {
        "id": "reboot-birth",
        "type": "function",
        "z": "edge-flow",
        "name": "Send Birth After Reboot",
        "func": "const topicParts = msg.topic.split('/');\nconst deviceCode = topicParts[1];\n\nconst deviceStates = flow.get('deviceStates') || {};\nconst state = deviceStates[deviceCode];\n\nif (!state) {\n    node.warn('Unknown device after reboot: ' + deviceCode);\n    return null;\n}\n\nconst config = state.config;\n\nmsg.topic = `edge/${deviceCode}/birth`;\nmsg.payload = {\n    deviceCode: deviceCode,\n    timestamp: new Date().toISOString(),\n    firmwareVersion: config.firmware,\n    ipAddress: config.ip,\n    properties: {\n        hardwareMake: config.model.includes('REVOLUTION') ? 'KUNBUS' : 'Custom',\n        hardwareModel: config.model,\n        firmwareVersion: config.firmware,\n        rebootComplete: true\n    }\n};\n\nnode.status({ fill: 'green', shape: 'dot', text: `Reboot complete: ${deviceCode}` });\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 850,
        "y": 420,
        "wires": [["mqtt-out-edge"]]
    },
    {
        "id": "mqtt-in-config",
        "type": "mqtt in",
        "z": "edge-flow",
        "name": "Config Commands",
        "topic": "edge/+/cmd/config",
        "qos": "1",
        "datatype": "json",
        "broker": "broker1",
        "nl": false,
        "rap": false,
        "inputs": 0,
        "x": 140,
        "y": 480,
        "wires": [["config-handler"]]
    },
    {
        "id": "config-handler",
        "type": "function",
        "z": "edge-flow",
        "name": "Handle Config Update",
        "func": "const topicParts = msg.topic.split('/');\nconst deviceCode = topicParts[1];\nconst commandId = msg.payload.commandId || 'unknown';\nconst newConfig = msg.payload.config || {};\n\nmsg.topic = `edge/${deviceCode}/response`;\nmsg.payload = {\n    commandId: commandId,\n    command: 'config',\n    success: true,\n    data: {\n        applied: true,\n        config: newConfig,\n        timestamp: new Date().toISOString()\n    }\n};\n\nnode.status({ fill: 'green', shape: 'dot', text: `Config updated: ${deviceCode}` });\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 400,
        "y": 480,
        "wires": [["mqtt-out-edge", "debug-response"]]
    },
    {
        "id": "mqtt-out-edge",
        "type": "mqtt out",
        "z": "edge-flow",
        "name": "Publish Edge Messages",
        "topic": "",
        "qos": "1",
        "retain": "false",
        "broker": "broker1",
        "x": 730,
        "y": 200,
        "wires": []
    },
    {
        "id": "debug-heartbeat",
        "type": "debug",
        "z": "edge-flow",
        "name": "Heartbeat Debug",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": true,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "payload.deviceCode",
        "statusType": "auto",
        "x": 710,
        "y": 260,
        "wires": []
    },
    {
        "id": "debug-response",
        "type": "debug",
        "z": "edge-flow",
        "name": "Response Debug",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": true,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "payload.command",
        "statusType": "auto",
        "x": 580,
        "y": 540,
        "wires": []
    },
    {
        "id": "comment-status",
        "type": "comment",
        "z": "edge-flow",
        "name": "=== PERIODIC STATUS BROADCAST ===",
        "info": "Broadcast all devices status every 30 seconds",
        "x": 190,
        "y": 580,
        "wires": []
    },
    {
        "id": "inject-status",
        "type": "inject",
        "z": "edge-flow",
        "name": "Every 30 seconds",
        "props": [{"p": "payload"}],
        "repeat": "30",
        "crontab": "",
        "once": true,
        "onceDelay": "10",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 150,
        "y": 640,
        "wires": [["status-broadcast"]]
    },
    {
        "id": "status-broadcast",
        "type": "function",
        "z": "edge-flow",
        "name": "Broadcast Fleet Status",
        "func": "const deviceStates = flow.get('deviceStates') || {};\nconst fleet = [];\n\nfor (let code in deviceStates) {\n    const state = deviceStates[code];\n    fleet.push({\n        deviceCode: code,\n        deviceName: state.config.name,\n        model: state.config.model,\n        isOnline: true,\n        cpuUsage: Math.round(state.cpuUsage),\n        memoryUsage: Math.round(state.memoryUsage),\n        storageUsage: Math.round(state.storageUsage),\n        temperatureCelsius: +state.temperatureCelsius.toFixed(1),\n        uptimeSeconds: state.uptimeSeconds,\n        firmwareVersion: state.config.firmware\n    });\n}\n\nmsg.topic = 'edge/fleet/status';\nmsg.payload = {\n    timestamp: new Date().toISOString(),\n    deviceCount: fleet.length,\n    onlineCount: fleet.length,\n    devices: fleet\n};\n\nnode.status({ fill: 'blue', shape: 'dot', text: `Fleet: ${fleet.length} devices` });\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 400,
        "y": 640,
        "wires": [["mqtt-out-edge", "debug-fleet"]]
    },
    {
        "id": "debug-fleet",
        "type": "debug",
        "z": "edge-flow",
        "name": "Fleet Status",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "x": 630,
        "y": 640,
        "wires": []
    }
]